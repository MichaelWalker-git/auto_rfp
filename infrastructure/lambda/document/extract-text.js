"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const lib_dynamodb_1 = require("@aws-sdk/lib-dynamodb");
const client_s3_1 = require("@aws-sdk/client-s3");
const client_textract_1 = require("@aws-sdk/client-textract");
const api_1 = require("../helpers/api");
const common_1 = require("../constants/common");
const document_1 = require("../constants/document");
// ---- Config ----
const REGION = process.env.AWS_REGION ||
    process.env.AWS_DEFAULT_REGION ||
    'us-east-1';
const DB_TABLE_NAME = process.env.DB_TABLE_NAME;
const DOCUMENTS_BUCKET = process.env.DOCUMENTS_BUCKET;
if (!DB_TABLE_NAME) {
    throw new Error('DB_TABLE_NAME environment variable is not set');
}
if (!DOCUMENTS_BUCKET) {
    throw new Error('DOCUMENTS_BUCKET environment variable is not set');
}
// singletons
const ddbClient = new client_dynamodb_1.DynamoDBClient({ region: REGION });
const docClient = lib_dynamodb_1.DynamoDBDocumentClient.from(ddbClient);
const s3Client = new client_s3_1.S3Client({ region: REGION });
const textractClient = new client_textract_1.TextractClient({ region: REGION });
// ---- Helpers ----
async function getDocumentById(documentId) {
    // We have a single-table with PK = DOCUMENT_PK and SK = `KB#...#DOC#<id>`
    // plus a top-level `id` attribute. We can query the partition and filter
    // by id. (Not perfect, but OK for our case.)
    const cmd = new lib_dynamodb_1.QueryCommand({
        TableName: DB_TABLE_NAME,
        KeyConditionExpression: '#pk = :pk',
        ExpressionAttributeNames: {
            '#pk': common_1.PK_NAME,
        },
        ExpressionAttributeValues: {
            ':pk': document_1.DOCUMENT_PK,
        },
        FilterExpression: 'id = :id',
        ExpressionAttributeValuesAdditional: undefined,
    });
    // TypeScript hack because lib-dynamodb doesn't like multiple EAV objects.
    cmd.input.ExpressionAttributeValues[':id'] = documentId;
    const res = await docClient.send(cmd);
    if (!res.Items || res.Items.length === 0) {
        throw new Error(`Document with id=${documentId} not found`);
    }
    return res.Items[0];
}
async function streamToString(body) {
    if (typeof body === 'string')
        return body;
    if (Buffer.isBuffer(body))
        return body.toString('utf-8');
    // Node.js SDK v3 stream
    return new Promise((resolve, reject) => {
        const chunks = [];
        body.on('data', (chunk) => chunks.push(chunk));
        body.on('error', reject);
        body.on('end', () => resolve(Buffer.concat(chunks).toString('utf-8')));
    });
}
function isTextKey(key) {
    const lower = key.toLowerCase();
    return (lower.endsWith('.txt') ||
        lower.endsWith('.md') ||
        lower.endsWith('.csv') ||
        lower.endsWith('.json') ||
        lower.endsWith('.log'));
}
// ---- Lambda handler (API-triggered, documentId in body) ----
const handler = async (event) => {
    try {
        if (!event.body) {
            return (0, api_1.apiResponse)(400, { message: 'Body is required' });
        }
        let body;
        try {
            body = JSON.parse(event.body);
        }
        catch {
            return (0, api_1.apiResponse)(400, { message: 'Invalid JSON body' });
        }
        const { documentId } = body;
        if (!documentId || typeof documentId !== 'string') {
            return (0, api_1.apiResponse)(400, {
                message: '`documentId` is required and must be a string',
            });
        }
        // 1) Load document from DynamoDB
        const doc = await getDocumentById(documentId);
        const fileKey = doc.fileKey;
        if (!fileKey) {
            return (0, api_1.apiResponse)(400, {
                message: `Document ${documentId} does not have fileKey`,
            });
        }
        // 2) Decide path based on file extension
        if (isTextKey(fileKey)) {
            // ---- SHORT-CIRCUIT: FILE IS ALREADY TEXT ----
            const getObj = await s3Client.send(new client_s3_1.GetObjectCommand({
                Bucket: DOCUMENTS_BUCKET,
                Key: fileKey,
            }));
            const text = await streamToString(getObj.Body);
            const response = {
                documentId,
                status: 'TEXT_READY',
                text,
                textS3Key: fileKey,
            };
            return (0, api_1.apiResponse)(200, response);
        }
        // 3) Non-text file → Start async Textract job and return jobId only.
        //    Step Function will handle waiting / polling in subsequent states.
        const startResp = await textractClient.send(new client_textract_1.StartDocumentTextDetectionCommand({
            DocumentLocation: {
                S3Object: {
                    Bucket: DOCUMENTS_BUCKET,
                    Name: fileKey,
                },
            },
            NotificationChannel: undefined, // you can wire SNS/SQS if you want callback-style
        }));
        if (!startResp.JobId) {
            throw new Error('Textract did not return JobId');
        }
        const response = {
            documentId,
            status: 'TEXTRACT_STARTED',
            textractJobId: startResp.JobId,
            s3Object: {
                bucket: DOCUMENTS_BUCKET,
                key: fileKey,
            },
        };
        // NOTE: we do NOT wait/poll here — Step Functions should:
        //   - Wait
        //   - Call a "get-textract-result" lambda with { textractJobId, documentId }
        //   - That lambda will assemble text, upload to S3, and return { text, textS3Key }
        return (0, api_1.apiResponse)(200, response);
    }
    catch (err) {
        console.error('Error in extract-text lambda:', err);
        return (0, api_1.apiResponse)(500, {
            message: 'Failed to start or perform text extraction',
            error: err instanceof Error ? err.message : 'Unknown error',
        });
    }
};
exports.handler = handler;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0cmFjdC10ZXh0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZXh0cmFjdC10ZXh0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUlBLDhEQUVrQztBQUNsQyx3REFHK0I7QUFDL0Isa0RBRzRCO0FBQzVCLDhEQUdrQztBQUVsQyx3Q0FBNkM7QUFDN0MsZ0RBQThDO0FBQzlDLG9EQUFvRDtBQUVwRCxtQkFBbUI7QUFFbkIsTUFBTSxNQUFNLEdBQ1YsT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFVO0lBQ3RCLE9BQU8sQ0FBQyxHQUFHLENBQUMsa0JBQWtCO0lBQzlCLFdBQVcsQ0FBQztBQUVkLE1BQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDO0FBQ2hELE1BQU0sZ0JBQWdCLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQztBQUV0RCxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDbkIsTUFBTSxJQUFJLEtBQUssQ0FBQywrQ0FBK0MsQ0FBQyxDQUFDO0FBQ25FLENBQUM7QUFDRCxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztJQUN0QixNQUFNLElBQUksS0FBSyxDQUFDLGtEQUFrRCxDQUFDLENBQUM7QUFDdEUsQ0FBQztBQUVELGFBQWE7QUFDYixNQUFNLFNBQVMsR0FBRyxJQUFJLGdDQUFjLENBQUMsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQztBQUN6RCxNQUFNLFNBQVMsR0FBRyxxQ0FBc0IsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDekQsTUFBTSxRQUFRLEdBQUcsSUFBSSxvQkFBUSxDQUFDLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7QUFDbEQsTUFBTSxjQUFjLEdBQUcsSUFBSSxnQ0FBYyxDQUFDLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7QUE2QjlELG9CQUFvQjtBQUVwQixLQUFLLFVBQVUsZUFBZSxDQUFDLFVBQWtCO0lBQy9DLDBFQUEwRTtJQUMxRSx5RUFBeUU7SUFDekUsNkNBQTZDO0lBQzdDLE1BQU0sR0FBRyxHQUFHLElBQUksMkJBQVksQ0FBQztRQUMzQixTQUFTLEVBQUUsYUFBYTtRQUN4QixzQkFBc0IsRUFBRSxXQUFXO1FBQ25DLHdCQUF3QixFQUFFO1lBQ3hCLEtBQUssRUFBRSxnQkFBTztTQUNmO1FBQ0QseUJBQXlCLEVBQUU7WUFDekIsS0FBSyxFQUFFLHNCQUFXO1NBQ25CO1FBQ0QsZ0JBQWdCLEVBQUUsVUFBVTtRQUM1QixtQ0FBbUMsRUFBRSxTQUFTO0tBQ3hDLENBQUMsQ0FBQztJQUVWLDBFQUEwRTtJQUN6RSxHQUFHLENBQUMsS0FBYSxDQUFDLHlCQUF5QixDQUFDLEtBQUssQ0FBQyxHQUFHLFVBQVUsQ0FBQztJQUVqRSxNQUFNLEdBQUcsR0FBRyxNQUFNLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFdEMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7UUFDekMsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQkFBb0IsVUFBVSxZQUFZLENBQUMsQ0FBQztJQUM5RCxDQUFDO0lBRUQsT0FBTyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FLakIsQ0FBQztBQUNKLENBQUM7QUFFRCxLQUFLLFVBQVUsY0FBYyxDQUMzQixJQUFTO0lBRVQsSUFBSSxPQUFPLElBQUksS0FBSyxRQUFRO1FBQUUsT0FBTyxJQUFJLENBQUM7SUFDMUMsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQztRQUFFLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUV6RCx3QkFBd0I7SUFDeEIsT0FBTyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRTtRQUNyQyxNQUFNLE1BQU0sR0FBYSxFQUFFLENBQUM7UUFDNUIsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxLQUFhLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUN2RCxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3pFLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVELFNBQVMsU0FBUyxDQUFDLEdBQVc7SUFDNUIsTUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ2hDLE9BQU8sQ0FDTCxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQztRQUN0QixLQUFLLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQztRQUNyQixLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQztRQUN0QixLQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQztRQUN2QixLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUN2QixDQUFDO0FBQ0osQ0FBQztBQUVELCtEQUErRDtBQUV4RCxNQUFNLE9BQU8sR0FBRyxLQUFLLEVBQzFCLEtBQTZCLEVBQ0ssRUFBRTtJQUNwQyxJQUFJLENBQUM7UUFDSCxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ2hCLE9BQU8sSUFBQSxpQkFBVyxFQUFDLEdBQUcsRUFBRSxFQUFFLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxDQUFDLENBQUM7UUFDM0QsQ0FBQztRQUVELElBQUksSUFBd0IsQ0FBQztRQUM3QixJQUFJLENBQUM7WUFDSCxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDaEMsQ0FBQztRQUFDLE1BQU0sQ0FBQztZQUNQLE9BQU8sSUFBQSxpQkFBVyxFQUFDLEdBQUcsRUFBRSxFQUFFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxDQUFDLENBQUM7UUFDNUQsQ0FBQztRQUVELE1BQU0sRUFBRSxVQUFVLEVBQUUsR0FBRyxJQUFJLENBQUM7UUFFNUIsSUFBSSxDQUFDLFVBQVUsSUFBSSxPQUFPLFVBQVUsS0FBSyxRQUFRLEVBQUUsQ0FBQztZQUNsRCxPQUFPLElBQUEsaUJBQVcsRUFBQyxHQUFHLEVBQUU7Z0JBQ3RCLE9BQU8sRUFBRSwrQ0FBK0M7YUFDekQsQ0FBQyxDQUFDO1FBQ0wsQ0FBQztRQUVELGlDQUFpQztRQUNqQyxNQUFNLEdBQUcsR0FBRyxNQUFNLGVBQWUsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUM5QyxNQUFNLE9BQU8sR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDO1FBQzVCLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNiLE9BQU8sSUFBQSxpQkFBVyxFQUFDLEdBQUcsRUFBRTtnQkFDdEIsT0FBTyxFQUFFLFlBQVksVUFBVSx3QkFBd0I7YUFDeEQsQ0FBQyxDQUFDO1FBQ0wsQ0FBQztRQUVELHlDQUF5QztRQUN6QyxJQUFJLFNBQVMsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDO1lBQ3ZCLGdEQUFnRDtZQUNoRCxNQUFNLE1BQU0sR0FBRyxNQUFNLFFBQVEsQ0FBQyxJQUFJLENBQ2hDLElBQUksNEJBQWdCLENBQUM7Z0JBQ25CLE1BQU0sRUFBRSxnQkFBZ0I7Z0JBQ3hCLEdBQUcsRUFBRSxPQUFPO2FBQ2IsQ0FBQyxDQUNILENBQUM7WUFFRixNQUFNLElBQUksR0FBRyxNQUFNLGNBQWMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFL0MsTUFBTSxRQUFRLEdBQWtDO2dCQUM5QyxVQUFVO2dCQUNWLE1BQU0sRUFBRSxZQUFZO2dCQUNwQixJQUFJO2dCQUNKLFNBQVMsRUFBRSxPQUFPO2FBQ25CLENBQUM7WUFFRixPQUFPLElBQUEsaUJBQVcsRUFBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDcEMsQ0FBQztRQUVELHFFQUFxRTtRQUNyRSx1RUFBdUU7UUFDdkUsTUFBTSxTQUFTLEdBQUcsTUFBTSxjQUFjLENBQUMsSUFBSSxDQUN6QyxJQUFJLG1EQUFpQyxDQUFDO1lBQ3BDLGdCQUFnQixFQUFFO2dCQUNoQixRQUFRLEVBQUU7b0JBQ1IsTUFBTSxFQUFFLGdCQUFnQjtvQkFDeEIsSUFBSSxFQUFFLE9BQU87aUJBQ2Q7YUFDRjtZQUNELG1CQUFtQixFQUFFLFNBQVMsRUFBRSxrREFBa0Q7U0FDbkYsQ0FBQyxDQUNILENBQUM7UUFFRixJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ3JCLE1BQU0sSUFBSSxLQUFLLENBQUMsK0JBQStCLENBQUMsQ0FBQztRQUNuRCxDQUFDO1FBRUQsTUFBTSxRQUFRLEdBQXdDO1lBQ3BELFVBQVU7WUFDVixNQUFNLEVBQUUsa0JBQWtCO1lBQzFCLGFBQWEsRUFBRSxTQUFTLENBQUMsS0FBSztZQUM5QixRQUFRLEVBQUU7Z0JBQ1IsTUFBTSxFQUFFLGdCQUFnQjtnQkFDeEIsR0FBRyxFQUFFLE9BQU87YUFDYjtTQUNGLENBQUM7UUFFRiwwREFBMEQ7UUFDMUQsV0FBVztRQUNYLDZFQUE2RTtRQUM3RSxtRkFBbUY7UUFFbkYsT0FBTyxJQUFBLGlCQUFXLEVBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO1FBQ2IsT0FBTyxDQUFDLEtBQUssQ0FBQywrQkFBK0IsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUNwRCxPQUFPLElBQUEsaUJBQVcsRUFBQyxHQUFHLEVBQUU7WUFDdEIsT0FBTyxFQUFFLDRDQUE0QztZQUNyRCxLQUFLLEVBQUUsR0FBRyxZQUFZLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsZUFBZTtTQUM1RCxDQUFDLENBQUM7SUFDTCxDQUFDO0FBQ0gsQ0FBQyxDQUFDO0FBL0ZXLFFBQUEsT0FBTyxXQStGbEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBUElHYXRld2F5UHJveHlFdmVudFYyLFxuICBBUElHYXRld2F5UHJveHlSZXN1bHRWMixcbn0gZnJvbSAnYXdzLWxhbWJkYSc7XG5pbXBvcnQge1xuICBEeW5hbW9EQkNsaWVudCxcbn0gZnJvbSAnQGF3cy1zZGsvY2xpZW50LWR5bmFtb2RiJztcbmltcG9ydCB7XG4gIER5bmFtb0RCRG9jdW1lbnRDbGllbnQsXG4gIFF1ZXJ5Q29tbWFuZCxcbn0gZnJvbSAnQGF3cy1zZGsvbGliLWR5bmFtb2RiJztcbmltcG9ydCB7XG4gIFMzQ2xpZW50LFxuICBHZXRPYmplY3RDb21tYW5kLFxufSBmcm9tICdAYXdzLXNkay9jbGllbnQtczMnO1xuaW1wb3J0IHtcbiAgVGV4dHJhY3RDbGllbnQsXG4gIFN0YXJ0RG9jdW1lbnRUZXh0RGV0ZWN0aW9uQ29tbWFuZCxcbn0gZnJvbSAnQGF3cy1zZGsvY2xpZW50LXRleHRyYWN0JztcblxuaW1wb3J0IHsgYXBpUmVzcG9uc2UgfSBmcm9tICcuLi9oZWxwZXJzL2FwaSc7XG5pbXBvcnQgeyBQS19OQU1FIH0gZnJvbSAnLi4vY29uc3RhbnRzL2NvbW1vbic7XG5pbXBvcnQgeyBET0NVTUVOVF9QSyB9IGZyb20gJy4uL2NvbnN0YW50cy9kb2N1bWVudCc7XG5cbi8vIC0tLS0gQ29uZmlnIC0tLS1cblxuY29uc3QgUkVHSU9OID1cbiAgcHJvY2Vzcy5lbnYuQVdTX1JFR0lPTiB8fFxuICBwcm9jZXNzLmVudi5BV1NfREVGQVVMVF9SRUdJT04gfHxcbiAgJ3VzLWVhc3QtMSc7XG5cbmNvbnN0IERCX1RBQkxFX05BTUUgPSBwcm9jZXNzLmVudi5EQl9UQUJMRV9OQU1FO1xuY29uc3QgRE9DVU1FTlRTX0JVQ0tFVCA9IHByb2Nlc3MuZW52LkRPQ1VNRU5UU19CVUNLRVQ7XG5cbmlmICghREJfVEFCTEVfTkFNRSkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0RCX1RBQkxFX05BTUUgZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbm90IHNldCcpO1xufVxuaWYgKCFET0NVTUVOVFNfQlVDS0VUKSB7XG4gIHRocm93IG5ldyBFcnJvcignRE9DVU1FTlRTX0JVQ0tFVCBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3Qgc2V0Jyk7XG59XG5cbi8vIHNpbmdsZXRvbnNcbmNvbnN0IGRkYkNsaWVudCA9IG5ldyBEeW5hbW9EQkNsaWVudCh7IHJlZ2lvbjogUkVHSU9OIH0pO1xuY29uc3QgZG9jQ2xpZW50ID0gRHluYW1vREJEb2N1bWVudENsaWVudC5mcm9tKGRkYkNsaWVudCk7XG5jb25zdCBzM0NsaWVudCA9IG5ldyBTM0NsaWVudCh7IHJlZ2lvbjogUkVHSU9OIH0pO1xuY29uc3QgdGV4dHJhY3RDbGllbnQgPSBuZXcgVGV4dHJhY3RDbGllbnQoeyByZWdpb246IFJFR0lPTiB9KTtcblxuLy8gLS0tLSBUeXBlcyAtLS0tXG5cbmludGVyZmFjZSBTdGFydEluZGV4aW5nSW5wdXQge1xuICBkb2N1bWVudElkOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBFeHRyYWN0VGV4dFJlc3BvbnNlX1RleHRSZWFkeSB7XG4gIGRvY3VtZW50SWQ6IHN0cmluZztcbiAgc3RhdHVzOiAnVEVYVF9SRUFEWSc7XG4gIHRleHQ6IHN0cmluZztcbiAgdGV4dFMzS2V5OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBFeHRyYWN0VGV4dFJlc3BvbnNlX1RleHRyYWN0U3RhcnRlZCB7XG4gIGRvY3VtZW50SWQ6IHN0cmluZztcbiAgc3RhdHVzOiAnVEVYVFJBQ1RfU1RBUlRFRCc7XG4gIHRleHRyYWN0Sm9iSWQ6IHN0cmluZztcbiAgczNPYmplY3Q6IHtcbiAgICBidWNrZXQ6IHN0cmluZztcbiAgICBrZXk6IHN0cmluZztcbiAgfTtcbn1cblxudHlwZSBFeHRyYWN0VGV4dFJlc3BvbnNlID1cbiAgfCBFeHRyYWN0VGV4dFJlc3BvbnNlX1RleHRSZWFkeVxuICB8IEV4dHJhY3RUZXh0UmVzcG9uc2VfVGV4dHJhY3RTdGFydGVkO1xuXG4vLyAtLS0tIEhlbHBlcnMgLS0tLVxuXG5hc3luYyBmdW5jdGlvbiBnZXREb2N1bWVudEJ5SWQoZG9jdW1lbnRJZDogc3RyaW5nKSB7XG4gIC8vIFdlIGhhdmUgYSBzaW5nbGUtdGFibGUgd2l0aCBQSyA9IERPQ1VNRU5UX1BLIGFuZCBTSyA9IGBLQiMuLi4jRE9DIzxpZD5gXG4gIC8vIHBsdXMgYSB0b3AtbGV2ZWwgYGlkYCBhdHRyaWJ1dGUuIFdlIGNhbiBxdWVyeSB0aGUgcGFydGl0aW9uIGFuZCBmaWx0ZXJcbiAgLy8gYnkgaWQuIChOb3QgcGVyZmVjdCwgYnV0IE9LIGZvciBvdXIgY2FzZS4pXG4gIGNvbnN0IGNtZCA9IG5ldyBRdWVyeUNvbW1hbmQoe1xuICAgIFRhYmxlTmFtZTogREJfVEFCTEVfTkFNRSxcbiAgICBLZXlDb25kaXRpb25FeHByZXNzaW9uOiAnI3BrID0gOnBrJyxcbiAgICBFeHByZXNzaW9uQXR0cmlidXRlTmFtZXM6IHtcbiAgICAgICcjcGsnOiBQS19OQU1FLFxuICAgIH0sXG4gICAgRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlczoge1xuICAgICAgJzpwayc6IERPQ1VNRU5UX1BLLFxuICAgIH0sXG4gICAgRmlsdGVyRXhwcmVzc2lvbjogJ2lkID0gOmlkJyxcbiAgICBFeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzQWRkaXRpb25hbDogdW5kZWZpbmVkLFxuICB9IGFzIGFueSk7XG5cbiAgLy8gVHlwZVNjcmlwdCBoYWNrIGJlY2F1c2UgbGliLWR5bmFtb2RiIGRvZXNuJ3QgbGlrZSBtdWx0aXBsZSBFQVYgb2JqZWN0cy5cbiAgKGNtZC5pbnB1dCBhcyBhbnkpLkV4cHJlc3Npb25BdHRyaWJ1dGVWYWx1ZXNbJzppZCddID0gZG9jdW1lbnRJZDtcblxuICBjb25zdCByZXMgPSBhd2FpdCBkb2NDbGllbnQuc2VuZChjbWQpO1xuXG4gIGlmICghcmVzLkl0ZW1zIHx8IHJlcy5JdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYERvY3VtZW50IHdpdGggaWQ9JHtkb2N1bWVudElkfSBub3QgZm91bmRgKTtcbiAgfVxuXG4gIHJldHVybiByZXMuSXRlbXNbMF0gYXMge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgZmlsZUtleTogc3RyaW5nO1xuICAgIGtub3dsZWRnZUJhc2VJZD86IHN0cmluZztcbiAgICBba2V5OiBzdHJpbmddOiBhbnk7XG4gIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHN0cmVhbVRvU3RyaW5nKFxuICBib2R5OiBhbnksXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSByZXR1cm4gYm9keTtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihib2R5KSkgcmV0dXJuIGJvZHkudG9TdHJpbmcoJ3V0Zi04Jyk7XG5cbiAgLy8gTm9kZS5qcyBTREsgdjMgc3RyZWFtXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgY2h1bmtzOiBCdWZmZXJbXSA9IFtdO1xuICAgIGJvZHkub24oJ2RhdGEnLCAoY2h1bms6IEJ1ZmZlcikgPT4gY2h1bmtzLnB1c2goY2h1bmspKTtcbiAgICBib2R5Lm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgYm9keS5vbignZW5kJywgKCkgPT4gcmVzb2x2ZShCdWZmZXIuY29uY2F0KGNodW5rcykudG9TdHJpbmcoJ3V0Zi04JykpKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzVGV4dEtleShrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBsb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gKFxuICAgIGxvd2VyLmVuZHNXaXRoKCcudHh0JykgfHxcbiAgICBsb3dlci5lbmRzV2l0aCgnLm1kJykgfHxcbiAgICBsb3dlci5lbmRzV2l0aCgnLmNzdicpIHx8XG4gICAgbG93ZXIuZW5kc1dpdGgoJy5qc29uJykgfHxcbiAgICBsb3dlci5lbmRzV2l0aCgnLmxvZycpXG4gICk7XG59XG5cbi8vIC0tLS0gTGFtYmRhIGhhbmRsZXIgKEFQSS10cmlnZ2VyZWQsIGRvY3VtZW50SWQgaW4gYm9keSkgLS0tLVxuXG5leHBvcnQgY29uc3QgaGFuZGxlciA9IGFzeW5jIChcbiAgZXZlbnQ6IEFQSUdhdGV3YXlQcm94eUV2ZW50VjIsXG4pOiBQcm9taXNlPEFQSUdhdGV3YXlQcm94eVJlc3VsdFYyPiA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKCFldmVudC5ib2R5KSB7XG4gICAgICByZXR1cm4gYXBpUmVzcG9uc2UoNDAwLCB7IG1lc3NhZ2U6ICdCb2R5IGlzIHJlcXVpcmVkJyB9KTtcbiAgICB9XG5cbiAgICBsZXQgYm9keTogU3RhcnRJbmRleGluZ0lucHV0O1xuICAgIHRyeSB7XG4gICAgICBib2R5ID0gSlNPTi5wYXJzZShldmVudC5ib2R5KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBhcGlSZXNwb25zZSg0MDAsIHsgbWVzc2FnZTogJ0ludmFsaWQgSlNPTiBib2R5JyB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGRvY3VtZW50SWQgfSA9IGJvZHk7XG5cbiAgICBpZiAoIWRvY3VtZW50SWQgfHwgdHlwZW9mIGRvY3VtZW50SWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gYXBpUmVzcG9uc2UoNDAwLCB7XG4gICAgICAgIG1lc3NhZ2U6ICdgZG9jdW1lbnRJZGAgaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgYSBzdHJpbmcnLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gMSkgTG9hZCBkb2N1bWVudCBmcm9tIER5bmFtb0RCXG4gICAgY29uc3QgZG9jID0gYXdhaXQgZ2V0RG9jdW1lbnRCeUlkKGRvY3VtZW50SWQpO1xuICAgIGNvbnN0IGZpbGVLZXkgPSBkb2MuZmlsZUtleTtcbiAgICBpZiAoIWZpbGVLZXkpIHtcbiAgICAgIHJldHVybiBhcGlSZXNwb25zZSg0MDAsIHtcbiAgICAgICAgbWVzc2FnZTogYERvY3VtZW50ICR7ZG9jdW1lbnRJZH0gZG9lcyBub3QgaGF2ZSBmaWxlS2V5YCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIDIpIERlY2lkZSBwYXRoIGJhc2VkIG9uIGZpbGUgZXh0ZW5zaW9uXG4gICAgaWYgKGlzVGV4dEtleShmaWxlS2V5KSkge1xuICAgICAgLy8gLS0tLSBTSE9SVC1DSVJDVUlUOiBGSUxFIElTIEFMUkVBRFkgVEVYVCAtLS0tXG4gICAgICBjb25zdCBnZXRPYmogPSBhd2FpdCBzM0NsaWVudC5zZW5kKFxuICAgICAgICBuZXcgR2V0T2JqZWN0Q29tbWFuZCh7XG4gICAgICAgICAgQnVja2V0OiBET0NVTUVOVFNfQlVDS0VULFxuICAgICAgICAgIEtleTogZmlsZUtleSxcbiAgICAgICAgfSksXG4gICAgICApO1xuXG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgc3RyZWFtVG9TdHJpbmcoZ2V0T2JqLkJvZHkpO1xuXG4gICAgICBjb25zdCByZXNwb25zZTogRXh0cmFjdFRleHRSZXNwb25zZV9UZXh0UmVhZHkgPSB7XG4gICAgICAgIGRvY3VtZW50SWQsXG4gICAgICAgIHN0YXR1czogJ1RFWFRfUkVBRFknLFxuICAgICAgICB0ZXh0LFxuICAgICAgICB0ZXh0UzNLZXk6IGZpbGVLZXksXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gYXBpUmVzcG9uc2UoMjAwLCByZXNwb25zZSk7XG4gICAgfVxuXG4gICAgLy8gMykgTm9uLXRleHQgZmlsZSDihpIgU3RhcnQgYXN5bmMgVGV4dHJhY3Qgam9iIGFuZCByZXR1cm4gam9iSWQgb25seS5cbiAgICAvLyAgICBTdGVwIEZ1bmN0aW9uIHdpbGwgaGFuZGxlIHdhaXRpbmcgLyBwb2xsaW5nIGluIHN1YnNlcXVlbnQgc3RhdGVzLlxuICAgIGNvbnN0IHN0YXJ0UmVzcCA9IGF3YWl0IHRleHRyYWN0Q2xpZW50LnNlbmQoXG4gICAgICBuZXcgU3RhcnREb2N1bWVudFRleHREZXRlY3Rpb25Db21tYW5kKHtcbiAgICAgICAgRG9jdW1lbnRMb2NhdGlvbjoge1xuICAgICAgICAgIFMzT2JqZWN0OiB7XG4gICAgICAgICAgICBCdWNrZXQ6IERPQ1VNRU5UU19CVUNLRVQsXG4gICAgICAgICAgICBOYW1lOiBmaWxlS2V5LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIE5vdGlmaWNhdGlvbkNoYW5uZWw6IHVuZGVmaW5lZCwgLy8geW91IGNhbiB3aXJlIFNOUy9TUVMgaWYgeW91IHdhbnQgY2FsbGJhY2stc3R5bGVcbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICBpZiAoIXN0YXJ0UmVzcC5Kb2JJZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0cmFjdCBkaWQgbm90IHJldHVybiBKb2JJZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlOiBFeHRyYWN0VGV4dFJlc3BvbnNlX1RleHRyYWN0U3RhcnRlZCA9IHtcbiAgICAgIGRvY3VtZW50SWQsXG4gICAgICBzdGF0dXM6ICdURVhUUkFDVF9TVEFSVEVEJyxcbiAgICAgIHRleHRyYWN0Sm9iSWQ6IHN0YXJ0UmVzcC5Kb2JJZCxcbiAgICAgIHMzT2JqZWN0OiB7XG4gICAgICAgIGJ1Y2tldDogRE9DVU1FTlRTX0JVQ0tFVCxcbiAgICAgICAga2V5OiBmaWxlS2V5LFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgLy8gTk9URTogd2UgZG8gTk9UIHdhaXQvcG9sbCBoZXJlIOKAlCBTdGVwIEZ1bmN0aW9ucyBzaG91bGQ6XG4gICAgLy8gICAtIFdhaXRcbiAgICAvLyAgIC0gQ2FsbCBhIFwiZ2V0LXRleHRyYWN0LXJlc3VsdFwiIGxhbWJkYSB3aXRoIHsgdGV4dHJhY3RKb2JJZCwgZG9jdW1lbnRJZCB9XG4gICAgLy8gICAtIFRoYXQgbGFtYmRhIHdpbGwgYXNzZW1ibGUgdGV4dCwgdXBsb2FkIHRvIFMzLCBhbmQgcmV0dXJuIHsgdGV4dCwgdGV4dFMzS2V5IH1cblxuICAgIHJldHVybiBhcGlSZXNwb25zZSgyMDAsIHJlc3BvbnNlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZXh0cmFjdC10ZXh0IGxhbWJkYTonLCBlcnIpO1xuICAgIHJldHVybiBhcGlSZXNwb25zZSg1MDAsIHtcbiAgICAgIG1lc3NhZ2U6ICdGYWlsZWQgdG8gc3RhcnQgb3IgcGVyZm9ybSB0ZXh0IGV4dHJhY3Rpb24nLFxuICAgICAgZXJyb3I6IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicsXG4gICAgfSk7XG4gIH1cbn07XG4iXX0=