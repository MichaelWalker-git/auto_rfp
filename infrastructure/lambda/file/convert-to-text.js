"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_s3_1 = require("@aws-sdk/client-s3");
const client_textract_1 = require("@aws-sdk/client-textract");
const api_1 = require("../helpers/api");
const REGION = process.env.AWS_REGION || 'us-east-1';
const DEFAULT_BUCKET = process.env.DOCUMENTS_BUCKET;
if (!DEFAULT_BUCKET) {
    throw new Error('DOCUMENTS_BUCKET environment variable is not set');
}
const s3Client = new client_s3_1.S3Client({ region: REGION });
const textractClient = new client_textract_1.TextractClient({ region: REGION });
const handler = async (event) => {
    try {
        if (!event.body) {
            return (0, api_1.apiResponse)(400, {
                message: 'Request body is required',
            });
        }
        const rawBody = event.isBase64Encoded
            ? Buffer.from(event.body, 'base64').toString('utf-8')
            : event.body;
        let body;
        try {
            body = JSON.parse(rawBody);
        }
        catch {
            return (0, api_1.apiResponse)(400, {
                message: 'Invalid JSON in request body',
            });
        }
        const { s3Key, s3Bucket } = body;
        if (!s3Key) {
            return (0, api_1.apiResponse)(400, {
                message: "'s3Key' is required in the request body",
            });
        }
        const bucketToUse = s3Bucket || DEFAULT_BUCKET;
        // 1) Load original file from S3 (still useful for non-PDF types)
        const fileBuffer = await getObjectAsBuffer(bucketToUse, s3Key);
        // 2) Detect extension
        const ext = getExtension(s3Key);
        // 3) Extract text based on type
        const text = await extractTextByExtension(ext, fileBuffer, bucketToUse, s3Key);
        if (!text || !text.trim()) {
            return (0, api_1.apiResponse)(400, {
                message: 'Extracted text is empty',
            });
        }
        // 4) Build output key (same path, .txt extension)
        const outputKey = buildTxtKey(s3Key);
        // 5) Store .txt file to S3
        await s3Client.send(new client_s3_1.PutObjectCommand({
            Bucket: bucketToUse,
            Key: outputKey,
            Body: Buffer.from(text, 'utf-8'),
            ContentType: 'text/plain; charset=utf-8',
        }));
        // 6) Return new key
        return (0, api_1.apiResponse)(200, {
            inputKey: s3Key,
            outputKey,
            bucket: bucketToUse,
        });
    }
    catch (error) {
        console.error('Error in normalize-to-text handler:', error);
        return (0, api_1.apiResponse)(500, {
            message: 'Failed to normalize document to text',
            error: error instanceof Error ? error.message : 'Unknown error',
        });
    }
};
exports.handler = handler;
/**
 * Read an S3 object and return its content as Buffer.
 */
async function getObjectAsBuffer(bucket, key) {
    const res = await s3Client.send(new client_s3_1.GetObjectCommand({
        Bucket: bucket,
        Key: key,
    }));
    if (!res.Body) {
        throw new Error('Empty S3 object body');
    }
    const body = res.Body;
    if (typeof body.transformToByteArray === 'function') {
        const arr = await body.transformToByteArray();
        return Buffer.from(arr);
    }
    return await new Promise((resolve, reject) => {
        const chunks = [];
        body.on('data', (chunk) => chunks.push(chunk));
        body.on('error', reject);
        body.on('end', () => resolve(Buffer.concat(chunks)));
    });
}
/**
 * Extract file extension from key.
 */
function getExtension(key) {
    const idx = key.lastIndexOf('.');
    if (idx === -1)
        return '';
    return key.slice(idx + 1).toLowerCase();
}
/**
 * Build txt output key next to original.
 * e.g. "folder/doc.pdf" -> "folder/doc.txt"
 */
function buildTxtKey(originalKey) {
    const idx = originalKey.lastIndexOf('.');
    if (idx === -1) {
        return `${originalKey}.txt`;
    }
    return `${originalKey.slice(0, idx)}.txt`;
}
/**
 * Route to appropriate transformer based on extension.
 * NOTE: PDFs now use Textract on the S3 object (multi-page-safe),
 * other types keep the simple placeholder logic.
 */
async function extractTextByExtension(ext, buffer, bucket, key) {
    switch (ext) {
        case 'txt':
            return buffer.toString('utf-8');
        case 'csv':
            return extractTextFromCsv(buffer);
        case 'xls':
        case 'xlsx':
            return extractTextFromExcel(buffer);
        case 'pdf':
            // ✅ use Textract async job on the S3 object
            return extractTextFromPdfWithTextract(bucket, key);
        case 'doc':
        case 'docx':
            return extractTextFromWord(buffer);
        default:
            console.warn(`Unsupported extension "${ext}", falling back to utf-8 text`);
            return buffer.toString('utf-8');
    }
}
/**
 * CSV → text
 */
function extractTextFromCsv(buffer) {
    return buffer.toString('utf-8');
}
/**
 * Excel → text (placeholder)
 */
function extractTextFromExcel(buffer) {
    return buffer.toString('utf-8');
}
/**
 * Word (doc/docx) → text (placeholder)
 */
function extractTextFromWord(buffer) {
    return buffer.toString('utf-8');
}
/**
 * PDF → text using Amazon Textract async APIs:
 * 1) StartDocumentTextDetection (S3 object)
 * 2) Poll GetDocumentTextDetection until SUCCEEDED
 * 3) Concatenate all LINE blocks into plain text
 */
async function extractTextFromPdfWithTextract(bucket, key) {
    // 1. Start async job
    const startRes = await textractClient.send(new client_textract_1.StartDocumentTextDetectionCommand({
        DocumentLocation: {
            S3Object: {
                Bucket: bucket,
                Name: key,
            },
        },
    }));
    const jobId = startRes.JobId;
    if (!jobId) {
        throw new Error('Textract did not return a JobId');
    }
    // 2. Poll until job finishes
    const blocks = [];
    let nextToken;
    const maxAttempts = 60; // e.g. up to ~2 minutes with 2s delay
    const delayMs = 2000;
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
        const res = await textractClient.send(new client_textract_1.GetDocumentTextDetectionCommand({
            JobId: jobId,
            NextToken: nextToken,
        }));
        const status = res.JobStatus;
        if (status === 'SUCCEEDED') {
            if (res.Blocks) {
                blocks.push(...res.Blocks);
            }
            if (res.NextToken) {
                nextToken = res.NextToken;
                // More pages – keep looping without waiting
                continue;
            }
            // All pages received
            break;
        }
        if (status === 'FAILED') {
            throw new Error(`Textract Job failed for ${bucket}/${key}: ${res.StatusMessage || 'unknown error'}`);
        }
        // IN_PROGRESS / PARTIAL_SUCCESS: wait and poll again
        await sleep(delayMs);
    }
    if (!blocks.length) {
        console.warn(`Textract returned no blocks for ${bucket}/${key}`);
        return '';
    }
    // 3. Glue all LINE texts into one plain-text blob
    const lines = blocks
        .filter((b) => b.BlockType === 'LINE' && b.Text)
        .map((b) => b.Text.trim());
    return lines.join('\n');
}
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udmVydC10by10ZXh0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29udmVydC10by10ZXh0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUlBLGtEQUk0QjtBQUM1Qiw4REFLa0M7QUFDbEMsd0NBQTZDO0FBRTdDLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxJQUFJLFdBQVcsQ0FBQztBQUNyRCxNQUFNLGNBQWMsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDO0FBRXBELElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUNwQixNQUFNLElBQUksS0FBSyxDQUFDLGtEQUFrRCxDQUFDLENBQUM7QUFDdEUsQ0FBQztBQUVELE1BQU0sUUFBUSxHQUFHLElBQUksb0JBQVEsQ0FBQyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDO0FBQ2xELE1BQU0sY0FBYyxHQUFHLElBQUksZ0NBQWMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDO0FBT3ZELE1BQU0sT0FBTyxHQUFHLEtBQUssRUFDMUIsS0FBNkIsRUFDSyxFQUFFO0lBQ3BDLElBQUksQ0FBQztRQUNILElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDaEIsT0FBTyxJQUFBLGlCQUFXLEVBQUMsR0FBRyxFQUFFO2dCQUN0QixPQUFPLEVBQUUsMEJBQTBCO2FBQ3BDLENBQUMsQ0FBQztRQUNMLENBQUM7UUFFRCxNQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsZUFBZTtZQUNuQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUM7WUFDckQsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUM7UUFFZixJQUFJLElBQTBCLENBQUM7UUFDL0IsSUFBSSxDQUFDO1lBQ0gsSUFBSSxHQUFH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eVByb3h5UmVzdWx0VjIsXG59IGZyb20gJ2F3cy1sYW1iZGEnO1xuaW1wb3J0IHtcbiAgR2V0T2JqZWN0Q29tbWFuZCxcbiAgUHV0T2JqZWN0Q29tbWFuZCxcbiAgUzNDbGllbnQsXG59IGZyb20gJ0Bhd3Mtc2RrL2NsaWVudC1zMyc7XG5pbXBvcnQge1xuICBUZXh0cmFjdENsaWVudCxcbiAgU3RhcnREb2N1bWVudFRleHREZXRlY3Rpb25Db21tYW5kLFxuICBHZXREb2N1bWVudFRleHREZXRlY3Rpb25Db21tYW5kLFxuICBCbG9jayxcbn0gZnJvbSAnQGF3cy1zZGsvY2xpZW50LXRleHRyYWN0JztcbmltcG9ydCB7IGFwaVJlc3BvbnNlIH0gZnJvbSAnLi4vaGVscGVycy9hcGknO1xuXG5jb25zdCBSRUdJT04gPSBwcm9jZXNzLmVudi5BV1NfUkVHSU9OIHx8ICd1cy1lYXN0LTEnO1xuY29uc3QgREVGQVVMVF9CVUNLRVQgPSBwcm9jZXNzLmVudi5ET0NVTUVOVFNfQlVDS0VUO1xuXG5pZiAoIURFRkFVTFRfQlVDS0VUKSB7XG4gIHRocm93IG5ldyBFcnJvcignRE9DVU1FTlRTX0JVQ0tFVCBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3Qgc2V0Jyk7XG59XG5cbmNvbnN0IHMzQ2xpZW50ID0gbmV3IFMzQ2xpZW50KHsgcmVnaW9uOiBSRUdJT04gfSk7XG5jb25zdCB0ZXh0cmFjdENsaWVudCA9IG5ldyBUZXh0cmFjdENsaWVudCh7IHJlZ2lvbjogUkVHSU9OIH0pO1xuXG5pbnRlcmZhY2UgTm9ybWFsaXplUmVxdWVzdEJvZHkge1xuICBzM0tleT86IHN0cmluZztcbiAgczNCdWNrZXQ/OiBzdHJpbmc7IC8vIG9wdGlvbmFsLCBmYWxscyBiYWNrIHRvIERPQ1VNRU5UU19CVUNLRVRcbn1cblxuZXhwb3J0IGNvbnN0IGhhbmRsZXIgPSBhc3luYyAoXG4gIGV2ZW50OiBBUElHYXRld2F5UHJveHlFdmVudFYyLFxuKTogUHJvbWlzZTxBUElHYXRld2F5UHJveHlSZXN1bHRWMj4gPT4ge1xuICB0cnkge1xuICAgIGlmICghZXZlbnQuYm9keSkge1xuICAgICAgcmV0dXJuIGFwaVJlc3BvbnNlKDQwMCwge1xuICAgICAgICBtZXNzYWdlOiAnUmVxdWVzdCBib2R5IGlzIHJlcXVpcmVkJyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHJhd0JvZHkgPSBldmVudC5pc0Jhc2U2NEVuY29kZWRcbiAgICAgID8gQnVmZmVyLmZyb20oZXZlbnQuYm9keSwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCd1dGYtOCcpXG4gICAgICA6IGV2ZW50LmJvZHk7XG5cbiAgICBsZXQgYm9keTogTm9ybWFsaXplUmVxdWVzdEJvZHk7XG4gICAgdHJ5IHtcbiAgICAgIGJvZHkgPSBKU09OLnBhcnNlKHJhd0JvZHkpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGFwaVJlc3BvbnNlKDQwMCwge1xuICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCBKU09OIGluIHJlcXVlc3QgYm9keScsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB7IHMzS2V5LCBzM0J1Y2tldCB9ID0gYm9keTtcblxuICAgIGlmICghczNLZXkpIHtcbiAgICAgIHJldHVybiBhcGlSZXNwb25zZSg0MDAsIHtcbiAgICAgICAgbWVzc2FnZTogXCInczNLZXknIGlzIHJlcXVpcmVkIGluIHRoZSByZXF1ZXN0IGJvZHlcIixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1Y2tldFRvVXNlID0gczNCdWNrZXQgfHwgREVGQVVMVF9CVUNLRVQ7XG5cbiAgICAvLyAxKSBMb2FkIG9yaWdpbmFsIGZpbGUgZnJvbSBTMyAoc3RpbGwgdXNlZnVsIGZvciBub24tUERGIHR5cGVzKVxuICAgIGNvbnN0IGZpbGVCdWZmZXIgPSBhd2FpdCBnZXRPYmplY3RBc0J1ZmZlcihidWNrZXRUb1VzZSwgczNLZXkpO1xuXG4gICAgLy8gMikgRGV0ZWN0IGV4dGVuc2lvblxuICAgIGNvbnN0IGV4dCA9IGdldEV4dGVuc2lvbihzM0tleSk7XG5cbiAgICAvLyAzKSBFeHRyYWN0IHRleHQgYmFzZWQgb24gdHlwZVxuICAgIGNvbnN0IHRleHQgPSBhd2FpdCBleHRyYWN0VGV4dEJ5RXh0ZW5zaW9uKGV4dCwgZmlsZUJ1ZmZlciwgYnVja2V0VG9Vc2UsIHMzS2V5KTtcblxuICAgIGlmICghdGV4dCB8fCAhdGV4dC50cmltKCkpIHtcbiAgICAgIHJldHVybiBhcGlSZXNwb25zZSg0MDAsIHtcbiAgICAgICAgbWVzc2FnZTogJ0V4dHJhY3RlZCB0ZXh0IGlzIGVtcHR5JyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIDQpIEJ1aWxkIG91dHB1dCBrZXkgKHNhbWUgcGF0aCwgLnR4dCBleHRlbnNpb24pXG4gICAgY29uc3Qgb3V0cHV0S2V5ID0gYnVpbGRUeHRLZXkoczNLZXkpO1xuXG4gICAgLy8gNSkgU3RvcmUgLnR4dCBmaWxlIHRvIFMzXG4gICAgYXdhaXQgczNDbGllbnQuc2VuZChcbiAgICAgIG5ldyBQdXRPYmplY3RDb21tYW5kKHtcbiAgICAgICAgQnVja2V0OiBidWNrZXRUb1VzZSxcbiAgICAgICAgS2V5OiBvdXRwdXRLZXksXG4gICAgICAgIEJvZHk6IEJ1ZmZlci5mcm9tKHRleHQsICd1dGYtOCcpLFxuICAgICAgICBDb250ZW50VHlwZTogJ3RleHQvcGxhaW47IGNoYXJzZXQ9dXRmLTgnLFxuICAgICAgfSksXG4gICAgKTtcblxuICAgIC8vIDYpIFJldHVybiBuZXcga2V5XG4gICAgcmV0dXJuIGFwaVJlc3BvbnNlKDIwMCwge1xuICAgICAgaW5wdXRLZXk6IHMzS2V5LFxuICAgICAgb3V0cHV0S2V5LFxuICAgICAgYnVja2V0OiBidWNrZXRUb1VzZSxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBub3JtYWxpemUtdG8tdGV4dCBoYW5kbGVyOicsIGVycm9yKTtcbiAgICByZXR1cm4gYXBpUmVzcG9uc2UoNTAwLCB7XG4gICAgICBtZXNzYWdlOiAnRmFpbGVkIHRvIG5vcm1hbGl6ZSBkb2N1bWVudCB0byB0ZXh0JyxcbiAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyxcbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZWFkIGFuIFMzIG9iamVjdCBhbmQgcmV0dXJuIGl0cyBjb250ZW50IGFzIEJ1ZmZlci5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0T2JqZWN0QXNCdWZmZXIoXG4gIGJ1Y2tldDogc3RyaW5nLFxuICBrZXk6IHN0cmluZyxcbik6IFByb21pc2U8QnVmZmVyPiB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHMzQ2xpZW50LnNlbmQoXG4gICAgbmV3IEdldE9iamVjdENvbW1hbmQoe1xuICAgICAgQnVja2V0OiBidWNrZXQsXG4gICAgICBLZXk6IGtleSxcbiAgICB9KSxcbiAgKTtcblxuICBpZiAoIXJlcy5Cb2R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBTMyBvYmplY3QgYm9keScpO1xuICB9XG5cbiAgY29uc3QgYm9keTogYW55ID0gcmVzLkJvZHk7XG5cbiAgaWYgKHR5cGVvZiBib2R5LnRyYW5zZm9ybVRvQnl0ZUFycmF5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgYXJyID0gYXdhaXQgYm9keS50cmFuc2Zvcm1Ub0J5dGVBcnJheSgpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShhcnIpO1xuICB9XG5cbiAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlPEJ1ZmZlcj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGNodW5rczogQnVmZmVyW10gPSBbXTtcbiAgICBib2R5Lm9uKCdkYXRhJywgKGNodW5rOiBCdWZmZXIpID0+IGNodW5rcy5wdXNoKGNodW5rKSk7XG4gICAgYm9keS5vbignZXJyb3InLCByZWplY3QpO1xuICAgIGJvZHkub24oJ2VuZCcsICgpID0+IHJlc29sdmUoQnVmZmVyLmNvbmNhdChjaHVua3MpKSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEV4dHJhY3QgZmlsZSBleHRlbnNpb24gZnJvbSBrZXkuXG4gKi9cbmZ1bmN0aW9uIGdldEV4dGVuc2lvbihrZXk6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGlkeCA9IGtleS5sYXN0SW5kZXhPZignLicpO1xuICBpZiAoaWR4ID09PSAtMSkgcmV0dXJuICcnO1xuICByZXR1cm4ga2V5LnNsaWNlKGlkeCArIDEpLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qKlxuICogQnVpbGQgdHh0IG91dHB1dCBrZXkgbmV4dCB0byBvcmlnaW5hbC5cbiAqIGUuZy4gXCJmb2xkZXIvZG9jLnBkZlwiIC0+IFwiZm9sZGVyL2RvYy50eHRcIlxuICovXG5mdW5jdGlvbiBidWlsZFR4dEtleShvcmlnaW5hbEtleTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgaWR4ID0gb3JpZ2luYWxLZXkubGFzdEluZGV4T2YoJy4nKTtcbiAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICByZXR1cm4gYCR7b3JpZ2luYWxLZXl9LnR4dGA7XG4gIH1cbiAgcmV0dXJuIGAke29yaWdpbmFsS2V5LnNsaWNlKDAsIGlkeCl9LnR4dGA7XG59XG5cbi8qKlxuICogUm91dGUgdG8gYXBwcm9wcmlhdGUgdHJhbnNmb3JtZXIgYmFzZWQgb24gZXh0ZW5zaW9uLlxuICogTk9URTogUERGcyBub3cgdXNlIFRleHRyYWN0IG9uIHRoZSBTMyBvYmplY3QgKG11bHRpLXBhZ2Utc2FmZSksXG4gKiBvdGhlciB0eXBlcyBrZWVwIHRoZSBzaW1wbGUgcGxhY2Vob2xkZXIgbG9naWMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RUZXh0QnlFeHRlbnNpb24oXG4gIGV4dDogc3RyaW5nLFxuICBidWZmZXI6IEJ1ZmZlcixcbiAgYnVja2V0OiBzdHJpbmcsXG4gIGtleTogc3RyaW5nLFxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgc3dpdGNoIChleHQpIHtcbiAgICBjYXNlICd0eHQnOlxuICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygndXRmLTgnKTtcblxuICAgIGNhc2UgJ2Nzdic6XG4gICAgICByZXR1cm4gZXh0cmFjdFRleHRGcm9tQ3N2KGJ1ZmZlcik7XG5cbiAgICBjYXNlICd4bHMnOlxuICAgIGNhc2UgJ3hsc3gnOlxuICAgICAgcmV0dXJuIGV4dHJhY3RUZXh0RnJvbUV4Y2VsKGJ1ZmZlcik7XG5cbiAgICBjYXNlICdwZGYnOlxuICAgICAgLy8g4pyFIHVzZSBUZXh0cmFjdCBhc3luYyBqb2Igb24gdGhlIFMzIG9iamVjdFxuICAgICAgcmV0dXJuIGV4dHJhY3RUZXh0RnJvbVBkZldpdGhUZXh0cmFjdChidWNrZXQsIGtleSk7XG5cbiAgICBjYXNlICdkb2MnOlxuICAgIGNhc2UgJ2RvY3gnOlxuICAgICAgcmV0dXJuIGV4dHJhY3RUZXh0RnJvbVdvcmQoYnVmZmVyKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBVbnN1cHBvcnRlZCBleHRlbnNpb24gXCIke2V4dH1cIiwgZmFsbGluZyBiYWNrIHRvIHV0Zi04IHRleHRgLFxuICAgICAgKTtcbiAgICAgIHJldHVybiBidWZmZXIudG9TdHJpbmcoJ3V0Zi04Jyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDU1Yg4oaSIHRleHRcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFRleHRGcm9tQ3N2KGJ1ZmZlcjogQnVmZmVyKTogc3RyaW5nIHtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygndXRmLTgnKTtcbn1cblxuLyoqXG4gKiBFeGNlbCDihpIgdGV4dCAocGxhY2Vob2xkZXIpXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RUZXh0RnJvbUV4Y2VsKGJ1ZmZlcjogQnVmZmVyKTogc3RyaW5nIHtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygndXRmLTgnKTtcbn1cblxuLyoqXG4gKiBXb3JkIChkb2MvZG9jeCkg4oaSIHRleHQgKHBsYWNlaG9sZGVyKVxuICovXG5mdW5jdGlvbiBleHRyYWN0VGV4dEZyb21Xb3JkKGJ1ZmZlcjogQnVmZmVyKTogc3RyaW5nIHtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygndXRmLTgnKTtcbn1cblxuLyoqXG4gKiBQREYg4oaSIHRleHQgdXNpbmcgQW1hem9uIFRleHRyYWN0IGFzeW5jIEFQSXM6XG4gKiAxKSBTdGFydERvY3VtZW50VGV4dERldGVjdGlvbiAoUzMgb2JqZWN0KVxuICogMikgUG9sbCBHZXREb2N1bWVudFRleHREZXRlY3Rpb24gdW50aWwgU1VDQ0VFREVEXG4gKiAzKSBDb25jYXRlbmF0ZSBhbGwgTElORSBibG9ja3MgaW50byBwbGFpbiB0ZXh0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RUZXh0RnJvbVBkZldpdGhUZXh0cmFjdChcbiAgYnVja2V0OiBzdHJpbmcsXG4gIGtleTogc3RyaW5nLFxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgLy8gMS4gU3RhcnQgYXN5bmMgam9iXG4gIGNvbnN0IHN0YXJ0UmVzID0gYXdhaXQgdGV4dHJhY3RDbGllbnQuc2VuZChcbiAgICBuZXcgU3RhcnREb2N1bWVudFRleHREZXRlY3Rpb25Db21tYW5kKHtcbiAgICAgIERvY3VtZW50TG9jYXRpb246IHtcbiAgICAgICAgUzNPYmplY3Q6IHtcbiAgICAgICAgICBCdWNrZXQ6IGJ1Y2tldCxcbiAgICAgICAgICBOYW1lOiBrZXksXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pLFxuICApO1xuXG4gIGNvbnN0IGpvYklkID0gc3RhcnRSZXMuSm9iSWQ7XG4gIGlmICgham9iSWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHRyYWN0IGRpZCBub3QgcmV0dXJuIGEgSm9iSWQnKTtcbiAgfVxuXG4gIC8vIDIuIFBvbGwgdW50aWwgam9iIGZpbmlzaGVzXG4gIGNvbnN0IGJsb2NrczogQmxvY2tbXSA9IFtdO1xuICBsZXQgbmV4dFRva2VuOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIGNvbnN0IG1heEF0dGVtcHRzID0gNjA7IC8vIGUuZy4gdXAgdG8gfjIgbWludXRlcyB3aXRoIDJzIGRlbGF5XG4gIGNvbnN0IGRlbGF5TXMgPSAyMDAwO1xuXG4gIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgbWF4QXR0ZW1wdHM7IGF0dGVtcHQrKykge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRleHRyYWN0Q2xpZW50LnNlbmQoXG4gICAgICBuZXcgR2V0RG9jdW1lbnRUZXh0RGV0ZWN0aW9uQ29tbWFuZCh7XG4gICAgICAgIEpvYklkOiBqb2JJZCxcbiAgICAgICAgTmV4dFRva2VuOiBuZXh0VG9rZW4sXG4gICAgICB9KSxcbiAgICApO1xuXG4gICAgY29uc3Qgc3RhdHVzID0gcmVzLkpvYlN0YXR1cztcbiAgICBpZiAoc3RhdHVzID09PSAnU1VDQ0VFREVEJykge1xuICAgICAgaWYgKHJlcy5CbG9ja3MpIHtcbiAgICAgICAgYmxvY2tzLnB1c2goLi4ucmVzLkJsb2Nrcyk7XG4gICAgICB9XG4gICAgICBpZiAocmVzLk5leHRUb2tlbikge1xuICAgICAgICBuZXh0VG9rZW4gPSByZXMuTmV4dFRva2VuO1xuICAgICAgICAvLyBNb3JlIHBhZ2VzIOKAkyBrZWVwIGxvb3Bpbmcgd2l0aG91dCB3YWl0aW5nXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gQWxsIHBhZ2VzIHJlY2VpdmVkXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSAnRkFJTEVEJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGV4dHJhY3QgSm9iIGZhaWxlZCBmb3IgJHtidWNrZXR9LyR7a2V5fTogJHtyZXMuU3RhdHVzTWVzc2FnZSB8fCAndW5rbm93biBlcnJvcid9YCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gSU5fUFJPR1JFU1MgLyBQQVJUSUFMX1NVQ0NFU1M6IHdhaXQgYW5kIHBvbGwgYWdhaW5cbiAgICBhd2FpdCBzbGVlcChkZWxheU1zKTtcbiAgfVxuXG4gIGlmICghYmxvY2tzLmxlbmd0aCkge1xuICAgIGNvbnNvbGUud2FybihgVGV4dHJhY3QgcmV0dXJuZWQgbm8gYmxvY2tzIGZvciAke2J1Y2tldH0vJHtrZXl9YCk7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLy8gMy4gR2x1ZSBhbGwgTElORSB0ZXh0cyBpbnRvIG9uZSBwbGFpbi10ZXh0IGJsb2JcbiAgY29uc3QgbGluZXMgPSBibG9ja3NcbiAgICAuZmlsdGVyKChiKSA9PiBiLkJsb2NrVHlwZSA9PT0gJ0xJTkUnICYmIGIuVGV4dClcbiAgICAubWFwKChiKSA9PiBiLlRleHQhLnRyaW0oKSk7XG5cbiAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xufVxuXG5mdW5jdGlvbiBzbGVlcChtczogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufVxuIl19